/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Stats counter */
export interface CounterStats {
  /** The counter value */
  value: number
  /** The counter description */
  description: string
}
/** Information about a direct address. */
export interface DirectAddrInfo {
  /** The address reported. */
  addr: string
  /** The latency to the address, if any. */
  latency?: number
  /** Last control message received by this node. */
  lastControlTime?: number
  lastControlMsg?: string
  /** How long ago was the last payload message for this node. */
  lastPayload?: number
  /** When was this connection last alive, if ever. */
  lastAlive?: number
}
/** The latency and type of the control message */
export interface LatencyAndControlMsg {
  /** The latency of the control message. In milliseconds */
  latency: number
  /** The type of control message, represented as a string */
  controlMsg: string
}
/** Information about a connection */
export interface ConnectionInfo {
  /** The node identifier of the endpoint. Also a public key. */
  nodeId: Array<number>
  /** Relay url, if available. */
  relayUrl?: string
  /**
   * List of addresses at which this node might be reachable, plus any latency information we
   * have about that address and the last time the address was used.
   */
  addrs: Array<DirectAddrInfo>
  /** The type of connection we have to the peer, either direct or over relay. */
  connType: ConnectionType
  /** The latency of the `conn_type`. In milliseconds. */
  latency?: number
  /** Duration since the last time this peer was used. In milliseconds. */
  lastUsed?: number
}
/** The type of the connection */
/** Indicates you have a UDP connection. */
Direct = 'Direct',
/** Indicates you have a relayed connection. */
Relay = 'Relay',
/** Indicates you have an unverified UDP connection, and a relay connection for backup. */
Mixed = 'Mixed',
/** Indicates you have no proof of connection. */
None = 'None'
/** The type of connection we have to the node */
export interface ConnectionType {
  /** The type of connection. */
  type: ConnType
  /** Details of the actual connection, dependent on the type. */
  details?: string
}
/** A peer and it's addressing information. */
export interface NodeAddr {
  nodeId: string
  /** Get the home relay URL for this peer */
  relayUrl?: string
  /** Direct addresses of this peer. */
  addresses: Array<string>
}
/** Options passed to [`IrohNode.new`]. Controls the behaviour of an iroh node. */
export interface NodeOptions {
  /**
   * How frequently the blob store should clean up unreferenced blobs, in milliseconds.
   * Set to null to disable gc
   */
  gcIntervalMillis?: number
}
/** The response to a status request */
export interface NodeStatus {
  /** The node id and socket addresses of this node. */
  addr: NodeAddr
  /** The bound listening addresses of the node */
  listenAddrs: Array<string>
  /** The version of the node */
  version: string
  /** RPC address, if currently listening. */
  rpcAddr?: string
}
function sum(a: number, b: number): number
/** The logging level. See the rust (log crate)[https://docs.rs/log] for more information. */
Trace = 'Trace',
Debug = 'Debug',
Info = 'Info',
Warn = 'Warn',
Error = 'Error',
Off = 'Off'
/** Set the logging level. */
function setLogLevel(level: LogLevel): void
/** Initialize the global metrics collection. */
function startMetricsCollection(): void
/**
 * Helper function that translates a key that was derived from the [`path_to_key`] function back
 * into a path.
 *
 * If `prefix` exists, it will be stripped before converting back to a path
 * If `root` exists, will add the root as a parent to the created path
 * Removes any null byte that has been appened to the key
 */
function keyToPath(key: Array<number>, prefix?: string | undefined | null, root?: string | undefined | null): string
/**
 * Helper function that creates a document key from a canonicalized path, removing the `root` and adding the `prefix`, if they exist
 *
 * Appends the null byte to the end of the key.
 */
function pathToKey(path: string, prefix?: string | undefined | null, root?: string | undefined | null): Array<number>
/**
 * A public key.
 *
 * The key itself is just a 32 byte array, but a key has associated crypto
 * information that is cached for performance reasons.
 */
export declare class PublicKey {
  /** Returns true if the PublicKeys are equal */
  equal(other: PublicKey): boolean
  /** Express the PublicKey as a byte array */
  toBytes(): Array<number>
  /** Make a PublicKey from base32 string */
  constructor(s: string)
  /**
   * Convert to a base32 string limited to the first 10 bytes for a friendly string
   * representation of the key.
   */
  fmtShort(): string
  /** Converts the public key into base32 string. */
  toString(): string
}
/** An Iroh node. Allows you to sync, store, and transfer data. */
export declare class Iroh {
  /**
   * Create a new iroh node.
   *
   * The `path` param should be a directory where we can store or load
   * iroh data from a previous session.
   */
  static persistent(path: string, opts?: NodeOptions | undefined | null): Promise<Iroh>
  /**
   * Create a new iroh node.
   *
   * All data will be only persistet in memory.
   */
  static memory(opts?: NodeOptions | undefined | null): Promise<Iroh>
  /** Access to node specific funtionaliy. */
  node(): Node
}
/** Iroh node client. */
export declare class Node {
  /** Get statistics of the running node. */
  stats(): Promise<Record<string, CounterStats>>
  /** Return `ConnectionInfo`s for each connection we have to another iroh node. */
  connections(): Promise<Array<ConnectionInfo>>
  /** Return connection information on the currently running node. */
  connectionInfo(nodeId: PublicKey): Promise<ConnectionInfo | null>
  /** Get status information about a node */
  status(): Promise<NodeStatus>
  /** The string representation of the PublicKey of this node. */
  nodeId(): Promise<string>
  /** Return the [`NodeAddr`] for this node. */
  nodeAddr(): Promise<NodeAddr>
  /** Add a known node address to the node. */
  addNodeAddr(addr: NodeAddr): Promise<void>
  /** Get the relay server we are connected to. */
  homeRelay(): Promise<string | null>
  /** Shutdown this iroh node. */
  shutdown(force: boolean): Promise<void>
  /** Returns `Some(addr)` if an RPC endpoint is running, `None` otherwise. */
  myRpcAddr(): string | null
}
