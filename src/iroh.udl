namespace iroh {
  void set_log_level(LogLevel level);
  [Throws=IrohError]
  void start_metrics_collection();
  [Throws=IrohError]
  bytes path_to_key(string path, string? prefix, string? root);
  [Throws=IrohError]
  string key_to_path(bytes key, string? prefix, string? root);
};

enum LogLevel {
  "Trace",
  "Debug",
  "Info",
  "Warn",
  "Error",
  "Off",
};

interface IrohNode {
  [Throws=IrohError]
  constructor(string path);
  string node_id();
  [Throws=IrohError]
  Doc doc_create();
  [Throws=IrohError]
  Doc doc_join(DocTicket ticket);
  [Throws=IrohError]
  sequence<NamespaceAndCapability> doc_list();
  [Throws=IrohError]
  AuthorId author_create();
  [Throws=IrohError]
  sequence<AuthorId> author_list();
  [Throws=IrohError]
  record<string, CounterStats> stats();
  [Throws=IrohError]
  sequence<ConnectionInfo> connections();
  [Throws=IrohError]
  ConnectionInfo? connection_info(PublicKey node_id);

  [Throws=IrohError]
  sequence<Hash> blobs_list();
  [Throws=IrohError]
  u64 blobs_size(Hash hash);
  [Throws=IrohError]
  bytes blobs_read_to_bytes(Hash hash);
  [Throws=IrohError]
  void blobs_add_from_path(string path, boolean in_place, SetTagOption tag, WrapOption wrap, AddCallback cb);
  [Throws=IrohError]
  void blobs_write_to_path(Hash hash, string path);
  [Throws=IrohError]
  BlobAddOutcome blobs_add_bytes(bytes bytes, SetTagOption tag);
  [Throws=IrohError]
  void blobs_download(BlobDownloadRequest req, DownloadCallback cb);
  [Throws=IrohError]
  sequence<BlobListIncompleteResponse> blobs_list_incomplete();
  [Throws=IrohError]
  sequence<BlobListCollectionsResponse> blobs_list_collections();
  [Throws=IrohError]
  void blobs_delete_blob(Hash hash);
};

interface Doc {
  NamespaceId id();
  [Throws=IrohError]
  void close(); 
  [Throws=IrohError]
  Hash set_bytes(AuthorId author, bytes key, bytes value);
  [Throws=IrohError]
  void set_hash(AuthorId author, bytes key, Hash hash, u64 size);
  [Throws=IrohError]
  void import_file(AuthorId author, bytes key, string path, boolean in_place, DocImportFileCallback? cb);
  [Throws=IrohError]
  void export_file(Entry entry, string path, DocExportFileCallback? cb);
  [Throws=IrohError]
  u64 size(Entry entry);
  [Throws=IrohError]
  bytes read_to_bytes(Entry entry);
  [Throws=IrohError]
  u64 del(AuthorId author_id, bytes prefix);
  [Throws=IrohError]
  Entry? get_one(Query query);
  [Throws=IrohError]
  sequence<Entry> get_many(Query query);
  [Throws=IrohError]
  DocTicket share(ShareMode mode);
  [Throws=IrohError]
  void start_sync(sequence<NodeAddr> peers);
  [Throws=IrohError]
  void leave();
  [Throws=IrohError]
  void subscribe(SubscribeCallback cb);
  [Throws=IrohError]
  OpenState status();
};

enum DocImportProgressType {
  "Found",
  "Progress",
  "IngestDone",
  "AllDone",
  "Abort"
};

dictionary DocImportProgressFound {
  u64 id;
  string name;
  u64 size;
};

dictionary DocImportProgressProgress {
  u64 id;
  u64 offset;
};

dictionary DocImportProgressIngestDone {
  u64 id;
  Hash hash;
};

dictionary DocImportProgressAllDone {
  bytes key;
};

dictionary DocImportProgressAbort {
  string error;
};

interface DocImportProgress {
  DocImportProgressType type();
  DocImportProgressFound as_found();
  DocImportProgressProgress as_progress();
  DocImportProgressIngestDone as_ingest_done();
  DocImportProgressAllDone as_all_done();
  DocImportProgressAbort as_abort();
};

callback interface DocImportFileCallback {
  [Throws=IrohError]
  void progress(DocImportProgress progress);
};

enum DocExportProgressType {
  "Found",
  "Progress",
  "AllDone",
  "Abort"
};

dictionary DocExportProgressFound {
  u64 id;
  Hash hash;
  bytes key;
  u64 size;
  string outpath;
};

dictionary DocExportProgressProgress {
  u64 id;
  u64 offset;
};

dictionary DocExportProgressAbort {
  string error;
};

interface DocExportProgress {
  DocExportProgressType type();
  DocExportProgressFound as_found();
  DocExportProgressProgress as_progress();
  DocExportProgressAbort as_abort();
};

callback interface DocExportFileCallback {
  [Throws=IrohError]
  void progress(DocExportProgress progress);
};

dictionary NamespaceAndCapability {
  NamespaceId namespace;
  CapabilityKind capability;
};

interface Query {
  [Name=all]
  constructor(QueryOptions? opts);
  [Name=single_latest_per_key]
  constructor(QueryOptions? opts);
  [Name=author]
  constructor(AuthorId author, QueryOptions? opts);
  [Name=key_exact]
  constructor(bytes key, QueryOptions? opts);
  [Name=author_key_exact]
  constructor(AuthorId author, bytes key);
  [Name=key_prefix]
  constructor(bytes prefix, QueryOptions? opts);
  [Name=author_key_prefix]
  constructor(AuthorId author, bytes prefix, QueryOptions? opts);
  u64 offset();
  u64? limit();
};

enum SortDirection {
  "Asc",
  "Desc",
};

enum CapabilityKind {
  "Write",
  "Read",
};

enum SortBy {
  "KeyAuthor",
  "AuthorKey",
};

enum ShareMode {
  "Read",
  "Write",
};

interface NodeAddr {
  constructor(PublicKey node_id, u16? region_id, sequence<SocketAddr> addresses);
  sequence<SocketAddr> direct_addresses();
  u16? derp_region();
  boolean equal(NodeAddr other);
};

callback interface SubscribeCallback {
  [Throws=IrohError]
  void event(LiveEvent event);
};

interface AuthorId {
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  boolean equal(AuthorId other);
};

interface Entry {
  AuthorId author();
  bytes key();
  NamespaceId namespace();
  Hash content_hash();
  u64 content_len();
};

interface Hash {
  constructor(bytes buf);
  string to_string();
  boolean equal(Hash other);
  bytes to_bytes();
  [Name=from_bytes, Throws=IrohError]
  constructor(bytes bytes);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  bytes as_cid_bytes();
  [Name=from_cid_bytes, Throws=IrohError]
  constructor(bytes bytes);
  string to_hex();
};

interface DocTicket {
  [Name=from_string, Throws=IrohError]
  constructor(string content);
  string to_string();
  boolean equal(DocTicket other);
};

dictionary OpenState {
  boolean sync;
  u64 subscribers;
  u64 handles;
};

dictionary CounterStats {
  u64 value;
  string description;
};

interface LiveEvent {
  LiveEventType type();
  Entry as_insert_local();
  InsertRemoteEvent as_insert_remote();
  Hash as_content_ready();
  PublicKey as_neighbor_up();
  PublicKey as_neighbor_down();
  SyncEvent as_sync_finished();
};

dictionary InsertRemoteEvent {
  PublicKey from;
  Entry entry;
  ContentStatus content_status;
};

[Enum]
interface LiveEventType {
  InsertLocal();
  InsertRemote();
  ContentReady();
  NeighborUp();
  NeighborDown();
  SyncFinished();
};

[Enum]
interface ContentStatus {
  Complete();
  Incomplete();
  Missing();
};

interface NamespaceId {
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  boolean equal(NamespaceId other);
};

dictionary SyncEvent {
  PublicKey peer;
  Origin origin;
  timestamp started;
  timestamp finished;
  string? result;
};

[Enum]
interface Origin {
  Connect(SyncReason reason);
  Accept();
};

enum SyncReason {
  "DirectJoin",
  "NewNeighbor",
  "SyncReport",
  "Resync",
};

dictionary QueryOptions {
  SortBy sort_by;
  SortDirection direction;
  u64 offset;
  u64 limit;
};

dictionary ConnectionInfo {
  PublicKey public_key;
  u16? derp_region;
  sequence<DirectAddrInfo> addrs;
  ConnectionType conn_type;
  duration? latency;
  duration? last_used;
};

[Enum]
interface ConnectionType{
  Direct(string addr, u16 port);
  Relay(u16 port);
  Mixed(string addr, u16 port);
  None();
};

interface DirectAddrInfo {};

enum SocketAddrType {
  "V4",
  "V6",
};

interface Ipv4Addr {
  constructor(u8 a, u8 b, u8 c, u8 d);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  sequence<u8> octets(); 
  boolean equal(Ipv4Addr other);
};

interface SocketAddrV4 {
  constructor(Ipv4Addr ipv4, u16 port);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  Ipv4Addr ip(); 
  u16 port();
  boolean equal(SocketAddrV4 other);
};

interface Ipv6Addr {
  constructor(u16 a, u16 b, u16 c, u16 d, u16 e, u16 f, u16 g, u16 h);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  sequence<u16> segments(); 
  boolean equal(Ipv6Addr other);
};

interface SocketAddrV6 {
  constructor(Ipv6Addr ipv6, u16 port);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  Ipv6Addr ip(); 
  u16 port();
  boolean equal(SocketAddrV6 other);
};

interface SocketAddr {
  [Name=from_ipv4]
  constructor(Ipv4Addr ipv4, u16 port);
  [Name=from_ipv6]
  constructor(Ipv6Addr ipv6, u16 port);
  SocketAddrType type();
  SocketAddrV4 as_ipv4();
  SocketAddrV6 as_ipv6();
  boolean equal(SocketAddr other);
};

interface PublicKey {
  string to_string();
  boolean equal(PublicKey other);
  bytes to_bytes();
  [Name=from_string, Throws=IrohError]
  constructor(string s); 
  [Name=from_bytes, Throws=IrohError]
  constructor(bytes bytes);
  string fmt_short();
};

interface Tag {
  string to_string();
  boolean equal(Tag other);
  bytes to_bytes();
  [Name=from_string]
  constructor(string s); 
  [Name=from_bytes]
  constructor(bytes bytes);
};

interface SetTagOption {
  [Name=auto]
  constructor();
  [Name=named]
  constructor(Tag tag);
};

interface WrapOption {
  [Name=no_wrap]
  constructor();
  [Name=wrap]
  constructor(string? name);
};

enum BlobFormat {
  "Raw",
  "HashSeq"
};

enum AddProgressType {
  "Found",
  "Progress",
  "Done",
  "AllDone",
  "Abort"
};

dictionary AddProgressFound {
  u64 id;
  string name;
  u64 size;
};

dictionary AddProgressProgress {
  u64 id;
  u64 offset;
};

dictionary AddProgressDone {
  u64 id;
  Hash hash;
};

dictionary AddProgressAllDone {
  Hash hash;
  BlobFormat format;
  Tag tag;
};

dictionary AddProgressAbort {
  string error;
};

interface AddProgress {
  AddProgressType type();
  AddProgressFound as_found();
  AddProgressProgress as_progress();
  AddProgressDone as_done();
  AddProgressAllDone as_all_done();
  AddProgressAbort as_abort();
};

callback interface AddCallback {
  [Throws=IrohError]
  void progress(AddProgress progress);
};

dictionary BlobAddOutcome {
  Hash hash;
  BlobFormat format;
  u64 size;
  Tag tag;
};

interface RequestToken {
  [Throws=IrohError]
  constructor(bytes bytes); 
  [Name=generate]
  constructor();
  bytes as_bytes();
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  boolean equal(RequestToken other);
};

interface DownloadLocation {
  [Name=internal]
  constructor();
  [Name=external]
  constructor(string path, boolean in_place);
};

interface BlobDownloadRequest {
  constructor(Hash hash, BlobFormat format, NodeAddr node, SetTagOption tag, DownloadLocation out, RequestToken? token);
};

callback interface DownloadCallback {
  [Throws=IrohError]
  void progress(DownloadProgress progress);
};

interface DownloadProgress {
  DownloadProgressType type();
  DownloadProgressFound as_found();
  DownloadProgressFoundHashSeq as_found_hash_seq();
  DownloadProgressProgress as_progress();
  DownloadProgressDone as_done();
  DownloadProgressNetworkDone as_network_done();
  DownloadProgressExport as_export();
  DownloadProgressExportProgress as_export_progress();
  DownloadProgressAbort as_abort();
};

dictionary DownloadProgressFound {
  u64 id;
  u64 child;
  Hash hash;
  u64 size;
};

dictionary DownloadProgressFoundHashSeq {
  u64 children;
  Hash hash;
};

dictionary DownloadProgressProgress {
  u64 id;
  u64 offset;
};

dictionary DownloadProgressDone {
  u64 id;
};

dictionary DownloadProgressNetworkDone {
  u64 bytes_written;
  u64 bytes_read;
  duration elapsed;
};

dictionary DownloadProgressExport {
  u64 id;
  Hash hash;
  u64 size;
  string target;
};

dictionary DownloadProgressExportProgress {
  u64 id;
  u64 offset;
};

dictionary DownloadProgressAbort {
  string error;
};

enum DownloadProgressType {
  "Connected",
  "Found",
  "FoundHashSeq",
  "Progress",
  "Done",
  "NetworkDone",
  "Export",
  "ExportProgress",
  "AllDone",
  "Abort",
};

dictionary BlobListResponse {
  string path;
  Hash hash;
  u64 size;
};

dictionary BlobListIncompleteResponse {
  u64 size;
  u64 expected_size;
  Hash hash;
};

dictionary BlobListCollectionsResponse {
  Tag tag;
  Hash hash;
  u64? total_blobs_count;
  u64? total_blobs_size;
};

[Error]
interface IrohError {
  Runtime(string description);
  NodeCreate(string description);
  Doc(string description);
  Author(string description);
  Namespace(string description);
  DocTicket(string description);
  Uniffi(string description);
  Connection(string description);
  Blobs(string description);
  Ipv4Addr(string description);
  Ipv6Addr(string description);
  SocketAddrV4(string description);
  SocketAddrV6(string description);
  PublicKey(string description);
  NodeAddr(string description);
  Hash(string description);
  RequestToken(string description);
  FsUtil(string description);
};
