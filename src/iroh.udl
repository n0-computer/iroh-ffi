namespace iroh {
  void set_log_level(LogLevel level);
  [Throws=IrohError]
  void start_metrics_collection();
};

enum LogLevel {
  "Trace",
  "Debug",
  "Info",
  "Warn",
  "Error",
  "Off",
};

interface IrohNode {
  [Throws=IrohError]
  constructor(string path);
  string node_id();
  [Throws=IrohError]
  Doc doc_new();
  [Throws=IrohError]
  Doc doc_join(DocTicket ticket);
  [Throws=IrohError]
  sequence<NamespaceId> doc_list();
  [Throws=IrohError]
  AuthorId author_new();
  [Throws=IrohError]
  sequence<AuthorId> author_list();
  [Throws=IrohError]
  record<string, CounterStats> stats();
  [Throws=IrohError]
  sequence<ConnectionInfo> connections();
  [Throws=IrohError]
  ConnectionInfo? connection_info(PublicKey node_id);

  [Throws=IrohError]
  sequence<Hash> blob_list_blobs();
  [Throws=IrohError]
  bytes blob_get(Hash hash);
};

interface Doc {
  string id();
  [Throws=IrohError]
  DocTicket share_write();
  [Throws=IrohError]
  DocTicket share_read();
  [Throws=IrohError]
  Hash set_bytes(AuthorId author, bytes key, bytes value);
  [Throws=IrohError]
  bytes get_content_bytes(Entry entry);
  [Throws=IrohError]
  sequence<Entry> keys();
  [Throws=IrohError]
  void subscribe(SubscribeCallback cb);
  [Throws=IrohError]
  void stop_sync();
  [Throws=IrohError]
  LiveStatus status();
};

callback interface SubscribeCallback {
  [Throws=IrohError]
  void event(LiveEvent event);
};

interface AuthorId {
  string to_string();
};

interface Entry {
  AuthorId author();
  bytes key();
  Hash hash();
};

interface Hash {
  string to_string();
  bytes to_bytes();
};

interface DocTicket {
  [Name=from_string, Throws=IrohError]
  constructor(string content);
  string to_string();
};

dictionary LiveStatus {
  boolean active;
  u64 subscriptions;
};

dictionary CounterStats {
  u64 value;
  string description;
};

interface LiveEvent {
  LiveEventType type();
  Entry as_insert_local();
  InsertRemoteEvent as_insert_remote();
  Hash as_content_ready();
  PublicKey as_neighbor_up();
  PublicKey as_neighbor_down();
  SyncEvent as_sync_finished();
};

dictionary InsertRemoteEvent {
  PublicKey from;
  Entry entry;
  ContentStatus content_status;
};

[Enum]
interface LiveEventType {
  InsertLocal();
  InsertRemote();
  ContentReady();
  NeighborUp();
  NeighborDown();
  SyncFinished();
  Closed();
};

[Enum]
interface ContentStatus {
  Complete();
  Incomplete();
  Missing();
};

interface NamespaceId {
  string to_string();
};

dictionary SyncEvent {
  NamespaceId namespace;
  PublicKey peer;
  Origin origin;
  f64 finished;
  string? result;
};

[Enum]
interface SyncReason {
  DirectJoin();
  NewNeighbor();
};

[Enum]
interface Origin {
  Connect(SyncReason reason);
  Accept();
};

dictionary ConnectionInfo {
  u64 id;
  PublicKey public_key;
  u16? derp_region;
  sequence<SocketAddr> addrs;
  sequence<double?> latencies;
  ConnectionType conn_type;
  double? latency;
};

[Enum]
interface ConnectionType{
  Direct(string addr, u16 port);
  Relay(u16 port);
  None();
};

enum SocketAddrType {
  "V4",
  "V6",
};

interface Ipv4Addr {
  constructor(u8 a, u8 b, u8 c, u8 d);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  sequence<u8> octets(); 
};

interface SocketAddrV4 {
  constructor(Ipv4Addr ipv4, u16 port);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  Ipv4Addr ip(); 
  u16 port();
};

interface Ipv6Addr {
  constructor(u16 a, u16 b, u16 c, u16 d, u16 e, u16 f, u16 g, u16 h);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  sequence<u16> segments(); 
};

interface SocketAddrV6 {
  constructor(Ipv6Addr ipv6, u16 port);
  [Name=from_string, Throws=IrohError]
  constructor(string str);
  string to_string();
  Ipv6Addr ip(); 
  u16 port();
};

interface SocketAddr {
  [Name=from_ipv4]
  constructor(Ipv4Addr ipv4, u16 port);
  [Name=from_ipv6]
  constructor(Ipv6Addr ipv6, u16 port);
  SocketAddrType type();
  [Throws=IrohError]
  SocketAddrV4 as_ipv4();
  [Throws=IrohError]
  SocketAddrV6 as_ipv6();
};

interface PublicKey {
  string to_string();
  bytes to_bytes();
  [Name=from_string, Throws=IrohError]
  constructor(string s); 
  [Name=from_bytes, Throws=IrohError]
  constructor(bytes bytes);
  string fmt_short();
};

[Error]
interface IrohError {
  Runtime(string description);
  NodeCreate(string description);
  Doc(string description);
  Author(string description);
  DocTicket(string description);
  Uniffi(string description);
  Connection(string description);
  Blob(string description);
  Ipv4Addr(string description);
  Ipv6Addr(string description);
  SocketAddrV4(string description);
  SocketAddrV6(string description);
  SocketAddr(string description);
  PublicKey(string description);
};
